<!-- Расстояние Левенштейна — это мера того, насколько две строки отличаются друг от друга. 
Оно показывает минимальное количество операций, чтобы превратить одну строку в другую. -->

<!-- Примеры для тестирования

1) Полное совпадение:   ATGC и ATGC

2) Одна замена:         ATGC и ATCC

3) Одно удаление:       ATGCA и ATGC

4) Одна вставка:        ATGC и ATGCC

5) Два удаления:        ATGCAATTGG и ATGCAAGG

6) Несколько изменений: ABCDEF и ABXDEZF
-->


<!-- CSS-стили Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
	integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

<body style="padding: 20px;">
	<div class="container"
		style="display: flex; justify-content: center; flex-direction: column; max-width: 800px; gap: 10px">

		<!-- Два текстовых поля -->
		<div style="display: flex; gap: 10px">
			<textarea type="text" id="str_input_1" class="form-control"></textarea>
			<textarea type="text" id="str_input_2" class="form-control"></textarea>
		</div>

		<!-- Кнопка для поиска решений -->
		<input type="button" value="Найти отличия" id="find_btn" class="btn btn-primary" />

		<!-- Блок для отображение результатов -->
		<div id="result"></div>
	</div>
</body>

<!-- Адаптив JavaScript Bootstrap -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
	integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
<script>
	// Функция для создание элементов с классами и текстом
	function createElement(tagName = "div", classList = [], text = "") {
		const element = document.createElement(tagName)
		classList.forEach(className => element.classList.add(className))
		element.appendChild(document.createTextNode(text))
		return element
	}

	// Функция для создания span элементов
	function span(classes = "", children = [], text = "") {
		const span = createElement("span", classes ? classes.split(" ") : [], text)
		children.forEach(child => span.appendChild(child))
		return span
	}

	// Проверка нескольких полей ввода
	function validate(inputs) {
		return inputs.reduce((flag, input) => {
			if (input.validate === undefined)
				return flag
			return input.validate()
		}, true)
	}

	// Проверка поля на пустоту
	const notEmptyValidator = function () {
		if (this.value.trim()) {
			this.classList.remove("is-invalid")
			return true
		}
		this.classList.add("is-invalid")
		return false
	}

	// Функция вычисления расстояний Левенштейна и поиска различий
	// сравнивает две строки и показывает какими именно отличия у них присутствуют
	// строит 2Д матрицу, заполняет ее числами и выбирает самый дешевый вариант изменений
	function levenshteinDistance(a, b) {
		// Создаем двумерный массив с размерами (a.length + 1) x (b.length + 1)
		const matrix = []
		for (let i = 0; i <= a.length; i++) {
			matrix[i] = []
			for (let j = 0; j <= b.length; j++)
				matrix[i][j] = 0
		}

		// Заполняем первую строку и первый столбец нулями
		for (let i = 0; i <= a.length; i++)
			matrix[i][0] = i
		for (let j = 0; j <= b.length; j++)
			matrix[0][j] = j

		// Заполняем остальные ячейки массива
		for (let i = 1; i <= a.length; i++) {
			for (let j = 1; j <= b.length; j++) {
				// Вычисляем расстояние Левенштейна для текущей ячейки
				const cost = a[i - 1] === b[j - 1] ? 0 : 1

				matrix[i][j] = Math.min(
					matrix[i - 1][j] + 1,       // Удаление символа
					matrix[i][j - 1] + 1,       // Вставка символа
					matrix[i - 1][j - 1] + cost // Замена символа
				)
			}
		}

		// восстановление последовательности изменений
		const result = []
		for (let i = 0; i < a.length; i++)
			result.push({ value: a[i] })  // изначально все символы без изменений

		// обратный проход для определения типов изменений
		let i = a.length
		j = b.length
		while (i != 0 && j != 0) {
			const cost = a[i - 1] === b[j - 1] ? 0 : 1
			del = matrix[i - 1][j] + 1
			ins = matrix[i][j - 1] + 1
			chg = matrix[i - 1][j - 1] + cost
			if (del < ins) {
				if (del < chg) {
					// del - удаление символа
					result[i - 1] = { type: "del", value: a[i - 1] }
					i--
				} else {
					// chg - замена символа
					if (cost) result[i - 1] = { type: "chg", value: b[j - 1] }
					i--
					j--
				}
			} else { // ins <= del - если вставка дешевле или равна удалению
				if (ins < chg) {
					// ins - вставка символа
					result.splice(i, 0, { type: "ins", value: b[j - 1] })
					j--
				} else {
					// chg - замена символа
					if (cost) result[i - 1] = { type: "chg", value: b[j - 1] }
					i--
					j--
				}
			}
		}

		return result // массив объектов с символами и типами изменений
	}

	// получение ссылок на элементы
	const input1 = document.getElementById("str_input_1")
	const input2 = document.getElementById("str_input_2")

	// назначение валидатора
	input1.validate = input2.validate = notEmptyValidator

	const button = document.getElementById("find_btn")
	const result = document.getElementById("result")

	// обработчик клика по кнопке
	button.addEventListener("click", function () {
		if (!validate([input1, input2]))
			return

		const s1 = input1.value.trim()
		const s2 = input2.value.trim()

		// создание контейнера для отображения различий
		const d = span("diff")
		
		// обработка каждого символа с учетом изменений
		for (const diff of levenshteinDistance(s1, s2)) {
			d.appendChild(span(diff.type || "", [], diff.value))
		}
		result.innerHTML = ""
		result.appendChild(d)
	});
</script>

<style>
	.diff span {
		background-color: var(--color);
		font-size: 32px;
	}

	span.chg {
		--color: rgba(229, 255, 0, 0.5);
	}

	span.del {
		--color: rgba(255, 0, 0, 0.5);
	}

	span.ins {
		--color: rgba(0, 255, 0, 0.5);
	}
</style>