#include <stdio.h>
#include <vector>
#include <cmath>
#include <numeric> // для использования accumulate()

using namespace std;

using ld = long double; // синоним типа
const ld eps = 1e-9; // очень маленькое значение


struct point
{
    ld x, y; // координаты
    point operator-(const point& a) const { return { x - a.x, y - a.y }; } // вычитание точек
    bool operator==(const point& a) const { return x == a.x && y == a.y; } // сравнение точек
    ld len() const { return sqrt(x * x + y * y); } // вычисление длины вектора
};

point f[10]; // столбы для забора
point v[100]; // градины
bool ans[100]; // отмечает доступные градины

// Для нахождения пересечения двух отрезков методом Крамера
// определения пересечения текущего сегмента забора с градиной
// это позволяет определить, падает ли градина в область действия лазера
// и уничтожается ли она
void intersect(ld& s, ld& t, point p1, point p2, point q1, point q2) 
{
    // Решает p1 + s*p2 = q1 = t*q2, используя правило Крамера.
    point d = q1 - p1;
    ld det = q2.x * p2.y - p2.x * q2.y;
    s = (q2.x * d.y - d.x * q2.y) / det;
    t = (p2.x * d.y - d.x * p2.y) / det;
}

int main() 
{
    int n, k;
    ld h, d, lx, ly, s, t;

    // Прочитать все введенные данные
    scanf_s("%d %Lf", &n, &h); // кол-во градин и высота забора

    for (int i = 0; i < n; i++) // координаты вершин многоугольника
        scanf_s("%Lf %Lf", &f[i].x, &f[i].y);

    scanf_s("%Lf %Lf %Lf %d", &d, &lx, &ly, &k); // дальность лазера - его координаты - кол-во градин
   
    for (int i = 0; i < k; i++) // координаты точек падения градин
        scanf_s("%Lf %Lf", &v[i].x, &v[i].y);


    for (int i = 0; i < n; i++) // для каждого сегмента забора
    { 
        point p1 = f[i], p2 = f[(i + 1) % n] - f[i]; // определение начала и конца вектора для текущего сегмента
        for (int j = 0; j < k; j++) // За каждую градину
        { 
            point q1 = { lx, ly }, q2 = (v[j] - q1); // определение начальной точки и направлющего вектора для текущей градины
            intersect(s, t, p1, p2, q1, q2); // поиск пересечения текущего сегмента забора с градиной
            // Если град прямо над нами, или лазер пересекает какой-то забор
            if (q1 == v[j] || s >= -eps && s <= 1 + eps && t >= 0) // проверка совпадение точек и пересечения сегмента с градиной
                // Определите минимальную высоту по подобным треугольникам и проверьте, находится ли она в пределах допустимого диапазона.
                if (sqrt(h * h / t / t + q2.len() * q2.len()) < d + eps) // проверка минимальной высоты
                    ans[j] = true; // обновление массива ответов
        }
    }

    // accumulate - используется для суммирования всех элементов в указанном диапазоне. Параметры: начальная итерация - конечная итерация  - начальное значение
    printf("%d", accumulate(ans, ans + 100, 0)); // вывод количества градин, попавших в область действия лазера и уничтоженных
}
