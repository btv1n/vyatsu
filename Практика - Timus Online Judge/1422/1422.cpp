#include <iostream>
#include <unordered_map> // неупорядоченный контейнер

using namespace std;

// Рекурсивные функции для нахождения НОД (Наибольший Общий Делитель)
int gcd(int a, int b) { return a == 0 ? b : gcd(b % a, a); }
int gcd(int a, int b, int c) { return gcd(a, gcd(b, c)); }


// Определение структуры vector3D, представляющей трехмерный вектор
struct vector3D
{
    // Координаты
    int x, y, z;

    // Перегрузка операторов вычитания, деления и сравнения для векторов.
    vector3D operator-(const vector3D& v2) { return { x - v2.x, y - v2.y, z - v2.z }; };
    vector3D operator/(int d) { return { x / d, y / d, z / d }; };
    bool operator==(const vector3D& v2) const { return x == v2.x && y == v2.y && z == v2.z; };

    // Определение внутренней структуры для хэширования векторов
    // XOR = ^ ; 1010 XOR 1100 = 0110 т.е 1 - когда 2 бита различны и 0 - когда одинаковы
    // Алгоритм работы функции хеширования заключается в том, что каждая координата вектора (x, y, z)
    // сначала хешируется отдельно с использованием стандартной функции хеширования для целых чисел 
    // (hash<int>()), а затем результаты объединяются с использованием операций XOR (^) и побитового 
    // сдвига (<<). Результат функции хеширования для вектора v будет состоять из трех хэш-значений 
    // для каждой из координат, объединенных в одно и возвращенных в качестве общего хэш-значения.
    struct Hash
    {
        // Перегруженные оператор принимает объект типа vector3D и возвращает хэш-значение
        size_t operator()(const vector3D& v) const
        {
            return hash<int>()(v.x) ^ (hash<int>()(v.y) << 11) ^ (hash<int>()(v.z) << 22);
        }
    };
};


int main()
{
    // Оптимизация
    ios::sync_with_stdio(false); // отключение синхронизации потоков ввода / вывода
    cin.tie(nullptr); // установка связи между потоками ввода и вывода на nullptr

    const int SIZE = 2000;
    vector3D A[SIZE];

    int n;
    int r = 1;

    cin >> n; // ввод кол-ва объектов в пространстве

    // Ввод координат векторов в массив A
    for (int i = 0; i < n; i++)
        cin >> A[i].x >> A[i].y >> A[i].z;

    for (int i = 0; i < n; i++) // цикл по всем векторам в массиве
    {
        // unordered_map параметры  (ключ типа "vector3D" - ключ типа int - хэш-функция типа "vector3D::Hash")
        // ассоциативный контейнер хранить пары ключ-значение а хеш-функция используется для быстрого доступа к элементам в "unordered_map" на основе ключей
        // Хэш-функция в unordered_map используется для определения индекса (хеша) каждого элемента в 
        // хэш-таблице. Она позволяет быстро перемещать или искать элементы в контейнере. При 
        // использовании хэш-функции скорость выполнения операции вставки, поиска и удаления О(1)
        unordered_map<vector3D, int, vector3D::Hash> m; // ассоциативный массив

        // Цикл по всем остальным векторам для нахождения НОД и обновления максимального 
        // значения "r". 
        for (int j = 0; j < n; j++) 
        {
            if (i == j)
                continue;

            vector3D v2 = A[j] - A[i]; // вычисление разности векторов
            vector3D g = v2 / gcd(v2.x, v2.y, v2.z); // вычисление вектора с единичными координатами
            r = max(r, 1 + ++m[g]); // обновление значения "r" с учетом нахождения одинаковых единичных векторов
        }
    }

    cout << r; // вывод максимального количества точек

    return 0;
}
